# Define the default image to use for all jobs.
image: node:20.10.0-alpine

services:
  # docker in docker service
  - name: docker:dind
    # explicitly disable tls to avoid docker startup interruption
    command: [ "--tls=false" ]

variables:
  # Instruct Testcontainers to use the daemon of DinD, use port 2735 for non-tls connections.
  DOCKER_HOST: "tcp://docker:2375"
  # Instruct Docker not to start over TLS.
  DOCKER_TLS_CERTDIR: ""
  # Improve performance with overlayfs.
  DOCKER_DRIVER: overlay2
  # Assign which kubernetes agent to use
  KUBE_CONTEXT: a10179/kubernetes-agent:kubernetes-agent

cache:
  key: ${CI_COMMIT_REF_SLUG}
  paths:
    - node_modules/
    - .npm/
    - .cache/
    - dist/

stages:
  - build
  - sonarqube-check
  - package
  - release
  - containerize
  - deploy

workflow:
  rules:
    - if: '$CI_COMMIT_BRANCH == "master"'
    - if: '$CI_COMMIT_BRANCH == "staging"'
    - if: '$CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH'
    - if: '$CI_COMMIT_BRANCH =~ /CMS*/'
    - if: '$CI_COMMIT_BRANCH =~ /DEVO*/'
    - if: '$CI_COMMIT_BRANCH =~ /hotfix*/'
    - if: '$CI_COMMIT_BRANCH == "updates-on-latest-features"'

.before_script:
  get_tool:
    # Check which package manager to use
    - |
      if [ -e pnpm-lock.yaml ]; then
        export tool=npm
      elif [ -e package-lock.json ]; then
        export tool=npm
      elif [ -e yarn.lock ]; then
        export tool=npm
      fi
    - echo "Using $tool"
    # Cjeck if the tool is installed, if not install it
    #- if [ "$tool" != "npm" ] && [ "$tool" != "yarn" ]; then npm install -g $tool; fi
  parse_version:
    - apk update && apk add jq
      # Parse version from package.json, trim the quotes and assign it to PARSE_VERSION
    - |
      PARSE_VERSION=$(jq '. | .version' package.json | tr -d '"')
      export PARSE_VERSION

      VAR=${PARSE_VERSION//-*/}
      export VAR

      TICKET_ID=$(echo "$CI_COMMIT_REF_NAME" | sed 's/\([A-Z-]*-[0-9]*\).*/\1/' | tr '[:upper:]' '[:lower:]')
      export TICKET_ID

      if [ "$CI_COMMIT_REF_NAME" = "develop" ]; then
        VERSION="$VAR-beta";
        export VERSION;
        jq '.version = "'"${VERSION}"'"' package.json > temp.json && mv temp.json package.json;
        DOCKER_TAG="$CI_REGISTRY_IMAGE:$VERSION";
        export DOCKER_TAG;
        POD_NAME="$CI_PROJECT_NAME-$CI_COMMIT_REF_NAME";
        export POD_NAME;
        APP_VERSION="$VERSION-beta";
        export APP_VERSION;
      elif [ "$CI_COMMIT_REF_NAME" = "master" ]; then
        VERSION="$VAR";
        export VERSION;
        jq '.version = "'"${VERSION}"'"' package.json > temp.json && mv temp.json package.json;
        DOCKER_TAG="$CI_REGISTRY_IMAGE:$VERSION";
        export DOCKER_TAG;
        POD_NAME="$CI_PROJECT_NAME-$CI_COMMIT_REF_NAME";
        export POD_NAME;
        APP_VERSION="$VERSION";
        export APP_VERSION;
      elif expr "$CI_COMMIT_REF_NAME" : ".*hotfix.*" > /dev/null ; then
        VERSION="$VAR-hf";
        export VERSION;
        jq '.version = "'"${VERSION}"'"' package.json > temp.json && mv temp.json package.json;
        DOCKER_TAG="$CI_REGISTRY_IMAGE:$VERSION-$TICKET_ID";
        export DOCKER_TAG;
        POD_NAME="$CI_PROJECT_NAME-$TICKET_ID";
        export POD_NAME;
        APP_VERSION="$VERSION-snapshot-$TICKET_ID";
        export APP_VERSION;
      else
        VERSION="$VAR-beta";
        export VERSION;
        DOCKER_TAG="$CI_REGISTRY_IMAGE:$VERSION-$TICKET_ID";
        export DOCKER_TAG;
        POD_NAME="$CI_PROJECT_NAME-$TICKET_ID";
        export POD_NAME;
        APP_VERSION="$VERSION-beta-$TICKET_ID";
        export APP_VERSION;
      fi

  npmrc-get:
    # The publish will fail if the package name and version combination already exists in the registry.
    # npmrc configuration for the npm package registry
    - echo "@blueai:registry=https://gitlab.com/api/v4/groups/a10179/-/packages/npm/" >> .npmrc
    - echo "//gitlab.com/api/v4/groups/a10179/-/packages/npm/:_authToken=${CI_JOB_TOKEN}" >> .npmrc
    - echo "legacy-peer-deps=true" >> .npmrc
    # Disable git checks to avoid gitlab ci pipeline failure
    - echo "git-checks=false" >> .npmrc

  npmrc-publish:
    # The publish will fail if the package name and version combination already exists in the registry.
    # npmrc configuration for the npm package registry
    - echo "@blueai:registry=https://${CI_SERVER_HOST}/api/v4/projects/${CI_PROJECT_ID}/packages/npm/" > .npmrc
    - echo "//${CI_SERVER_HOST}/api/v4/projects/${CI_PROJECT_ID}/packages/npm/:_authToken=${CI_JOB_TOKEN}" >> .npmrc
    # Disable git checks to avoid gitlab ci pipeline failure
    - echo "git-checks=false" >> .npmrc
    - cat .npmrc

build:
  image: node:18-alpine
  rules:
    - if: $CI_COMMIT_TAG
      when: never
    - if: $CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "staging" || $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: always
    - when: manual
  allow_failure: false
  stage: build
  before_script:
    - !reference [.before_script, get_tool]
    - !reference [.before_script, parse_version]
    - !reference [.before_script, npmrc-get]
    - apk add git
  script:
    - $tool install
    - $tool run build
  timeout: 5min
  artifacts:
    paths:
      - dist/

version-check:
  image: node:18-alpine
  rules:
    - changes: 
        - package.json
        - package-lock.json
        - yarn.lock
    - if: $CI_COMMIT_TAG
      when: never
    - if: $CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "staging" || $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: always
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
      when: never
    - when: manual
  allow_failure: false
  stage: build
  before_script:
    - !reference [.before_script, parse_version]
    - apk add git
  script:
    - |
      if [ "$CI_COMMIT_REF_NAME" = "develop" ] || [ "$CI_COMMIT_REF_NAME" = "master" ] || [ "$CI_COMMIT_REF_NAME" = "staging" ]; then
        CHECK=$(git tag -l "$VERSION" || true);
        export CHECK
        if [ -n "$CHECK" ]; then
          echo "Version $VERSION already exists, exiting..."
          exit 1
        else
          echo "Version $VERSION does not exist, continuing..."
          exit 0
        fi
      else
        CHECK=$(git tag -l "$PARSE_VERSION" || true);
        export CHECK
        if [ -n "$CHECK" ]; then
          echo "Version $PARSE_VERSION already exists, exiting..."
          exit 1
        else
          echo "Version $PARSE_VERSION does not exist, continuing..."
          exit 0
        fi
      fi
  timeout: 5min

sonarqube-check:
  when: manual
  rules:
    - if: $CI_COMMIT_TAG
      when: never
  needs:
    - job: build
  image:
    name: sonarsource/sonar-scanner-cli:latest
    entrypoint: [""]
  variables:
    # Disable the shallow clone, so that sonarqube can get the full history.
    GIT_DEPTH: "0"
  stage: sonarqube-check
  before_script:
    - apk add gettext
    - envsubst < sonar-project.properties.template > sonar-project.properties
  script:
    - sonar-scanner
  allow_failure: true
  after_script:
    # Get the sonarqube metrics and severities using the sonarqube api, parse the json using jq, and print the results.
    - |
      apk add jq curl
      curl -u $SONAR_RESULTS_TOKEN: "$SONAR_METRICS_API?component=$SONAR_PROJECT_KEY&branch=$CI_COMMIT_BRANCH&$SONAR_METRICKEYS" | jq '.c.measures'
      curl -u $SONAR_RESULTS_TOKEN: "$SONAR_SEVERITIES_API?componentKeys=$SONAR_PROJECT_KEY&branch=$CI_COMMIT_BRANCH&$SONAR_SEVERITIESKEY" | jq '.facets'
  timeout: 5min

package:
  stage: package
  image: node:20.10.0-alpine
  needs:
    - job: build
      artifacts: true
    - job: version-check
  rules:
    - if: $CI_COMMIT_TAG
      when: never
    - if: $CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "staging" || $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: on_success
    - if: $CI_COMMIT_BRANCH =~ /hotfix*/
      when: manual
    - when: never
  before_script:
    - !reference [.before_script, get_tool]
    - !reference [.before_script, parse_version]
    - !reference [.before_script, npmrc-publish]
  script:
    # Check npm configuration (logs)
    - npm config list -l
    - jq '. | .version' package.json | tr -d '"'
    # Save the version to variable.env file
    - echo "VERSION=$VERSION" > variables.env
    - echo "PARSE_VERSION=$PARSE_VERSION" >> variables.env
    # Publish the package to the npm registry
    - $tool publish
  timeout: 5min
  artifacts:
    reports:
      # This job will create a file called variables.env
      dotenv: variables.env

build-docker-image:
  stage: containerize
  needs:
    # If mvn-package job fails, this job will be skipped
    - job: build
      artifacts: true
  image: docker:latest
  rules:
    - if: $CI_COMMIT_TAG
      when: never
    - if: $CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "staging" || $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: on_success
    - if: $CI_COMMIT_BRANCH =~ /hotfix*/
      when: manual
    - if: $CI_MERGE_REQUEST_EVENT_TYPE == "merge_request"
      when: never
    - when: manual
  services:
    - docker:dind
  before_script:
    - !reference [.before_script, parse_version]
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
  script:
    - echo $DOCKER_TAG
    - docker pull $CI_REGISTRY_IMAGE:latest || true
    - docker build --build-arg NPM_READ_TOKEN="${NPM_READ_TOKEN}" -f Dockerfile.ci -t $DOCKER_TAG .
    - docker push $DOCKER_TAG
    - echo "VERSION=$VERSION" > variables.env
    - echo "PARSE_VERSION=$PARSE_VERSION" >> variables.env
    - echo "DOCKER_TAG=$DOCKER_TAG" >> variables.env
    - echo "APP_VERSION=$APP_VERSION" >> variables.env
  artifacts:
    reports:
      # This job will create a file called variables.env
      dotenv: variables.env

tag_release:
  stage: release
  image: alpine:latest
  needs:
    - job: build
      artifacts: true
      optional: true
    - job: package
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH && $CI_MERGE_REQUEST_SOURCE_BRANCH_NAME == "master"
      when: never
    - if: $CI_COMMIT_TAG || $CI_COMMIT_BRANCH == "master"
      when: never
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: on_success
    - if: $CI_COMMIT_BRANCH == "staging"
      when: on_success
    - if: $CI_COMMIT_BRANCH =~ /hotfix*/
      when: manual
    - when: never
  before_script:
    - !reference [.before_script, parse_version]
    - apk add git
  script:
    - git config --global user.name "RELEASE_TOKEN"
    - git config --global user.email $RELEASE_TOKEN_EMAIL@noreply.gitlab.com
    - git remote set-url origin "https://RELEASE_TOKEN:$RELEASE_TOKEN@gitlab.com/$CI_PROJECT_PATH.git"
    - git checkout $CI_COMMIT_BRANCH
    - git tag -a $VERSION -m "Release $VERSION"
    - git push --follow-tags -o ci.skip
  timeout: 5min

release:
  stage: release
  image: registry.gitlab.com/gitlab-org/release-cli:latest
  needs:
    - job: package
      artifacts: true
  rules:
    # If branch name is not master, this job will be skipped
    - if: $CI_COMMIT_BRANCH == "master"
      when: on_success
  before_script:
    - !reference [.before_script, parse_version]
    - apk add git
  script:
    - git config --global user.name "RELEASE_TOKEN"
    - git config --global user.email $RELEASE_TOKEN_EMAIL@noreply.gitlab.com
    - git remote set-url origin "https://RELEASE_TOKEN:$RELEASE_TOKEN@gitlab.com/$CI_PROJECT_PATH.git"
    - git checkout $CI_COMMIT_BRANCH
    - git add . && git commit -m "$PARSE_VERSION -> $VERSION"
    - git push --follow-tags -o ci.skip
  # add pushing commits to master
    - echo "running release_job for version $VERSION"
  release:
    # This job will create a release on gitlab
    name: '$VERSION'
    description: 'Created using the release-cli'
    tag_name: '$VERSION'
    ref: '$CI_COMMIT_SHA'

.deploy:
  create_tls:
    - export SECRET_NAME="$CI_PROJECT_NAME-tls"
    - apk add openssl
    - |
        if kubectl get secret $SECRET_NAME --namespace=$NAMESPACE &> /dev/null; then
            echo "Secret $SECRET_NAME already exists. Skipping creation."
        else
            echo "Creating secret $SECRET_NAME..."
            openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout $CI_PROJECT_NAME.key -out $CI_PROJECT_NAME.cert -subj "/CN=$HOST/O=blue.ai"
            kubectl create secret tls $SECRET_NAME \
                --cert=$CI_PROJECT_NAME.cert \
                --key=$CI_PROJECT_NAME.key \
                --namespace=$NAMESPACE
        fi


  deploy_to_environment:
    - echo $DOCKER_TAG
    - echo $APP_VERSION
    # Replace variables in values.tmpl with values from variables.env
    - |
      if [ -f ./deployments/"$CI_PROJECT_NAME"/values.yaml ]; then
          envsubst < ./deployments/"$CI_PROJECT_NAME"/values.tmpl > ./deployments/"$CI_PROJECT_NAME"/values.yaml
          helm upgrade -i --dry-run "$CI_PROJECT_NAME" ./deployments/"$CI_PROJECT_NAME" -f ./deployments/"$CI_PROJECT_NAME"/values.yaml -n "$NAMESPACE" || { echo "helm upgrade --dry-run failed"; exit 1;}
          echo "dry run checks out, upgrading..."
          helm upgrade -i "$CI_PROJECT_NAME" ./deployments/"$CI_PROJECT_NAME" -f ./deployments/"$CI_PROJECT_NAME"/values.yaml -n "$NAMESPACE" --version $APP_VERSION --wait --timeout 600s
          helm_upgrade_exit_status=$?
          export helm_upgrade_exit_status
          if [ "$helm_upgrade_exit_status" -eq 0 ]; then
              echo "helm upgrade succeeded"
              exit 0
          else
              echo "helm upgrade failed, exit status: $helm_upgrade_exit_status"
              echo "Rolling back to the previous version..."
              previous_version=$(helm history -n "$NAMESPACE" "$CI_PROJECT_NAME" | tail -n 1 | awk '{print $1}' | head -n 1)
              export previous_versi
              if [ "$previous_version" -eq 0 ]; then
                  echo "no previous version found"
                  exit 1
              else
                  echo "rolling back to version $previous_version"
                  helm rollback -n "$NAMESPACE" "$CI_PROJECT_NAME" "$previous_version" --wait --timeout 600s
                  helm_rollback_exit_status=$?
                  export helm_rollback_exit_status
                  if [ "$helm_rollback_exit_status" -eq 0 ]; then
                      echo "helm rollback succeeded"
                      exit 1
                  else
                      echo "helm rollback failed, exit status: $helm_rollback_exit_status"
                      exit 1
                  fi
              fi
          fi
      elif [ -f ./deployments/deployment.tmpl ]; then
        envsubst < ./deployments/deployment.tmpl > ./deployments/deployment.yaml
        kubectl apply -f ./deployments/deployment.yaml
        kubectl rollout restart deployment "${CI_PROJECT_NAME}" -n "$NAMESPACE"
        if kubectl rollout status deployment "${CI_PROJECT_NAME}" -n "$NAMESPACE" --timeout=300s; then
          echo "Deployment succeeded"
          kubectl annotate deployments.apps "${CI_PROJECT_NAME}" -n "$NAMESPACE" kubernetes.io/change-cause="version ${version}" --overwrite=true
          kubectl rollout history deployment "${CI_PROJECT_NAME}" -n "$NAMESPACE" | tail -n 2 | echo "Deployment revision: $(awk '{print $1}' | head -n 1)"
        else
          echo "Deployment failed"
          kubectl rollout undo deployment "${CI_PROJECT_NAME}" -n "$NAMESPACE"
          kubectl rollout history deployment "${CI_PROJECT_NAME}" -n "$NAMESPACE" | tail -n 2 | echo "Deployment revision: $(awk '{print $1}' | head -n 1)"
          exit 1
        fi
      else
          echo "no deployment file found"
          exit 1
      fi

deploy-to-develop:
  stage: deploy
  environment: develop
  # This job needs release_job and build-docker-image to run and succeed
  needs:
    - job: build-docker-image
      artifacts: true
  variables:
    # Set namespace based on project name as a variable
    NAMESPACE: $CI_PROJECT_NAME-develop
    VITE_APP_PREFIX: ${VITE_APP_PREFIX}
    VITE_APP_API_BASE_URL: ${VITE_APP_API_BASE_URL}
    HOST: cms.develop.rdev.antwerptechnologies.com
  image:
    # Use helm and kubectl image
    name: dtzar/helm-kubectl:3.13
    # Override entrypoint to use bash
    entrypoint: [""]
  rules:
    # This job will only run if branch name is master
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: manual
    - if: $CI_COMMIT_BRANCH =~ /DEVO*/
      when: manual
    - when: never
  before_script:
    # This job needs the before_script from .kube-requirments to run
    - if [ -n "$KUBE_CONTEXT" ]; then kubectl config use-context "$KUBE_CONTEXT"; fi
    - !reference [.deploy, create_tls]
  script:
    #- !reference [.deploy, deploy_to_environment]
    - ./deployments/scripts/deploy-to-environment.sh

deploy-to-qa:
  stage: deploy
  environment: qa
  # This job needs release_job and build-docker-image to run and succeed
  needs:
    - job: build-docker-image
      artifacts: true
  variables:
    # Set namespace based on project name as a variable
    NAMESPACE: $CI_PROJECT_NAME-qa
    VITE_APP_PREFIX: ${VITE_APP_PREFIX}
    VITE_APP_API_BASE_URL: ${VITE_APP_API_BASE_URL}
    HOST: cms.qa.rdev.antwerptechnologies.com
  image:
    # Use helm and kubectl image
    name: dtzar/helm-kubectl:3.13
    # Override entrypoint to use bash
    entrypoint: [""]
  rules:
    # This job will only run if branch name is master
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: manual
    - if: $CI_COMMIT_BRANCH =~ /DEVO*/
      when: manual
    - when: never
  before_script:
    # This job needs the before_script from .kube-requirments to run
    - if [ -n "$KUBE_CONTEXT" ]; then kubectl config use-context "$KUBE_CONTEXT"; fi
    - !reference [.deploy, create_tls]
  script:
    #- !reference [.deploy, deploy_to_environment]
    - ./deployments/scripts/deploy-to-environment.sh

deploy-to-dev:
  stage: deploy
  environment: dev
  # This job needs release_job and build-docker-image to run and succeed
  needs:
    - job: build-docker-image
      artifacts: true
  variables:
    # Set namespace based on project name as a variable
    NAMESPACE: dev-shour
    VITE_APP_PREFIX: ${VITE_APP_PREFIX}
    VITE_APP_API_BASE_URL: ${VITE_APP_API_BASE_URL}
    HOST: 'cms.${NAMESPACE}.rdev.antwerptechnologies.com'
  image:
    # Use helm and kubectl image
    name: dtzar/helm-kubectl:3.13
    # Override entrypoint to use bash
    entrypoint: [""]
  rules:
    # This job will only run if branch name is master
    - if: $CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "staging" || $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: never
    - when: manual
  before_script:
    # This job needs the before_script from .kube-requirments to run
    - if [ -n "$KUBE_CONTEXT" ]; then kubectl config use-context "$KUBE_CONTEXT"; fi
    - !reference [.deploy, create_tls]
  script:
    # - !reference [.deploy, deploy_to_environment]
    - ./deployments/scripts/deploy-to-environment.sh
